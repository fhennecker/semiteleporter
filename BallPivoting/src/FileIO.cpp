/** @file FileIO.cpp
 * @brief file defining methods to read points from a file
 * see FileIO.h for methods declaration
 * @author Julie Digne julie.digne@liris.cnrs.fr
 * @date 2012/10/22
 * @copyright This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published 
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
 */


#include "FileIO.h"
#include<iostream>
#include<fstream>
#include<istream>
#include<ostream>
#include<sstream>
#include <limits>

using namespace std;


FileIO::FileIO()
{
}

FileIO::~FileIO()
{
}



bool FileIO::readAndSortPoints(const char* filename, Octree& octree,
                               double min_radius)
{
    ifstream in;
    in.open(filename);

    if(!in)
    {
        std::cerr<<"File "<<filename<<" could not be opened"<<std::endl;
        return false;
    }

    string firstline;

    getline(in, firstline);

    istringstream line_in(firstline);
    string word;
    int nword = 0;
    while (line_in>> word)
        nword++;

    if(nword == 3)
    {
        std::cerr<< "Only three doubles per line: unoriented points?"
           <<"This program needs oriented points!"<<endl;
        return false;
    }

    if( nword != 6)
    {
        std::cerr<<"each point must be given by 6 values (position + normal) :"
            <<"x y z nx ny nz"<<endl;
        return false;
    }

    in.clear() ;
    in.seekg(0, ios::beg);

    double x,y,z,nx,ny,nz;
    in >> x >> y >> z >> nx >> ny >> nz;

    list<Vertex> input_vertices;
    input_vertices.push_back(Vertex(x,y,z,nx,ny,nz));

    double xmin, ymin, zmin, xmax, ymax, zmax;
    xmin = xmax = x;
    ymin = ymax = y;
    zmin = zmax = z;

    while( in >> x >> y >> z >> nx >> ny >> nz)
    {
        input_vertices.push_back(Vertex(x,y,z,nx,ny,nz));

        xmin = x < xmin ? x : xmin;
        xmax = x > xmax ? x : xmax;
        ymin = y < ymin ? y : ymin;
        ymax = y > ymax ? y : ymax;
        zmin = z < zmin ? z : zmin;
        zmax = z > zmax ? z : zmax;
    }
    in.close();

    std::cout<<input_vertices.size()<<" points read"<<std::endl;

    double lx = xmax - xmin;
    double ly = ymax - ymin;
    double lz = zmax - zmin;

    double size = lx > ly ? lx : ly;
    size = size > lz ? size : lz;


    size = 1.1 * size;
    double margin;


    if(min_radius > 0)
    {
        unsigned int depth = (unsigned int)ceil( log2( size / (min_radius) ));
        double adapted_size = pow2(depth) * min_radius;
        margin = 0.5 * (adapted_size - size);
        size = adapted_size;
        octree.setDepth(depth);
    }
    else
    {
        margin = 0.05 * size;
    }

    double ox = xmin - margin;
    double oy = ymin - margin;
    double oz = zmin - margin;
    Point origin(ox,oy,oz);

    octree.initialize(origin, size);

    octree.addPoints(input_vertices.begin(), input_vertices.end());

    return true;
}

bool FileIO::savePoints(const char* filename, Octree& octree)
{
    ofstream out;
    out.open(filename);
    out.precision( numeric_limits<double>::digits10 + 1);

    if(!out)
        return false;

    OctreeNode *node = octree.getRoot();
    saveContent(node, out);

    out.close();

    return true;
}




bool FileIO::saveMesh(const char* filename, Mesher& mesher)
{
    ofstream out;
    out.open(filename);
    out.precision( numeric_limits<double>::digits10 + 1);
    
    if(!out)
    { // file couldn't be opened
    cerr << "Error: file could not be opened" << endl;
    return false;
    }

    out << "ply" << endl;
    out << "format ascii 1.0" << endl;
    out << "comment Mesh generated by the Ball Pivoting Algorithm" << endl;
    out << "element vertex "<< mesher.nVertices() << endl;
    out << "property float x" << endl;
    out << "property float y" << endl;
    out << "property float z" << endl;
    out << "property float nx" << endl;
    out << "property float ny" << endl;
    out << "property float nz" << endl;
    out << "element face "<< mesher.nFacets() << endl;
    out << "property list uchar int vertex_indices"<< endl;
    out << "end_header" << endl;

    for( Vertex_star_list::const_iterator vi = mesher.vertices_begin();
        vi != mesher.vertices_end(); ++vi)
    {
        Vertex *v = *vi;
        out<< *v << endl;
    }

    for( Facet_star_list::const_iterator fi = mesher.facets_begin();
        fi != mesher.facets_end(); ++fi)
    {
        out << 3 << "\t";
        const Facet* f = *fi;

        Vertex *v0 = f->vertex(0);
        Vertex *v1 = f->vertex(1);
        Vertex *v2 = f->vertex(2);

        double nx = v0->nx() + v1->nx() + v2->nx();
        double ny = v0->ny() + v1->ny() + v2->ny();
        double nz = v0->nz() + v1->nz() + v2->nz();

        double tx = v1->x() - v0->x();
        double ty = v1->y() - v0->y();
        double tz = v1->z() - v0->z();

        double sx = v2->x() - v0->x();
        double sy = v2->y() - v0->y();
        double sz = v2->z() - v0->z();

        double cprodx, cprody, cprodz;
        cross_product(tx, ty, tz, sx, sy, sz, cprodx, cprody, cprodz);


        if( nx * cprodx + ny * cprody + nz * cprodz > 0)
        {
            out << v0->index() <<"\t";
            out << v1->index() <<"\t";
            out << v2->index() <<endl;
        }
        else
        {
            out << v0->index() <<"\t";
            out << v2->index() <<"\t";
            out << v1->index() <<endl;
        }
    }
    return true;
}


void FileIO::saveContent(OctreeNode* node, ofstream& f)
{
    if(node->getDepth() != 0)
    {
        for(int i = 0; i < 8 ;i++)
            if(node->getChild(i) != NULL)
                saveContent(node->getChild(i), f);
    }
    else if(node->getNpts() != 0)
    {
        Vertex_list::const_iterator iter;
        for(iter = node->points_begin(); iter != node->points_end();
            ++iter)
        {
            f << *iter <<std::endl;
        }
    }
}

